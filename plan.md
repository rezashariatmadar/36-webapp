# 36 webapp

## Project Overview & Tech Stack

This project integrates a **coworking space reservation system** with a **café management system** for a seamless customer and staff experience. We will use **Django** (Python) for the backend, leveraging its robust ORM and admin capabilities, and **SQLite** for development (easy setup) with **PostgreSQL** for production (scalable, reliable database)[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/GEMINI.md#L10-L15). The frontend will be primarily **Django Templates** with standard HTML/CSS and minimal JavaScript, which is a stack that AI coding assistants handle well. This avoids complex frontend frameworks and keeps the implementation straightforward[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/GEMINI.md#L120-L124). Key libraries (as needed) may include Django’s built-in auth, Pillow for image handling, and perhaps a library for generating QR codes or charts (for analytics)[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/GEMINI.md#L10-L15).

We will structure the code in a modular fashion for clarity. In Django, this can mean separate apps for distinct domains (e.g., **cafe** app and **reservation** app) or a unified app if cross-module relationships are easier to manage[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/GEMINI.md#L64-L70). Given the interconnected nature (orders may link to reservations), a single Django app (or a shared database schema) might reduce complexity of cross-app foreign keys[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/GEMINI.md#L64-L70). Regardless of app structure, we’ll implement features in phases: first the core user/auth system, then the café menu and order management, and finally the seat reservation system (utilizing the provided floor plan SVG/JPG for the UI). This phased approach ensures each component is solid before integrating the next.

## Authentication & User Management

The authentication system will use **phone numbers as usernames** and **Iranian National ID codes as passwords**. We will customize the Django User model or use a OneToOne extension (Profile) to store phone number and national ID for each user[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/GEMINI.md#L30-L34). Key points include:

- **Phone as Username:** Enforce unique phone numbers for login. We can either set `USERNAME_FIELD = 'phone'` in a custom user model or handle authentication via a custom backend that treats phone as the credential. This allows users to log in with their phone number (which is easy to remember and unique). The system will require phone number format validation (e.g. valid Iran mobile format if applicable, starting with 09…). Optionally, integrate SMS verification in the future for extra security (not in initial scope).
- **National ID as Password:** During signup, the user’s initial password will be their Iranian national ID (10-digit code). We will implement an algorithm to **verify the integrity of the National ID** before accepting it. This involves checking that the ID is 10 digits, not all identical, and that the last digit is a valid checksum of the preceding digits. For example, we can compute a weighted sum of the first 9 digits (weights 10 down to 2) and ensure the remainder matches the check digit (with the known formula for Iran’s national code validation) – if `sum mod 11 < 2`, the check digit should equal `sum mod 11`, else it should equal `11 - (sum mod 11)`[stackoverflow.com](https://stackoverflow.com/questions/68150111/how-to-validate-national-identity-shenaseh-meli-of-iranian-legal-people#:~:text=int%20delta%20%3D%200%3B%20int,remain%3B%20return%20remain%20%3D%3D%20checkDigit). This ensures users enter a **valid national code**. The national ID (being used as a password) will be stored hashed in the database like any password for security, but we will also store the plain ID in the user’s profile for reference/verification purposes. Additionally, we may allow/force the user to change this default password later for security (since national IDs can be sensitive).
- **User Profile Data:** Beyond phone and national ID, the system will maintain a profile for each user. We’ll store the user’s name and contact info, and possibly an **image of their national ID card** for administrative verification (as hinted by the repository, a `UserProfile` with an ID image field)[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/GEMINI.md#L30-L34). This can help the admin verify that the provided national ID belongs to the user (especially important if memberships are exclusive to real identities).
- **Roles and Permissions:** We have three main user roles: **Admin**, **Barista**, and **Customer**. (An optional **Receptionist** role could be added if front-desk duties are split, but the admin can cover those in this plan.) We will use Django’s Group and Permission system to differentiate what each role can do:
    - **Admin (you):** Full access. Admin can manage everything: user accounts, menu and inventory, view all orders and reservations, adjust settings, and see all analytics.
    - **Barista:** Can access the café management section – e.g., view incoming orders, mark orders as prepared or delivered, input manual orders for walk-in customers, and update item availability. Baristas should not manage coworking reservations or sensitive admin settings. We will create a Django Group “Barista” and assign appropriate model permissions (like add/change CafeOrder, etc.)[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/cafe/management/commands/setup_groups.py#L10-L17).
    - **Customer:** Regular users (members or one-time visitors). They can log in, view the **real-time seat availability** map, book a seat/room, and view/place café orders. Customers can see their own orders’ status and past orders, and manage their reservations (e.g., cancel a booking within allowed rules). They won’t have access to admin dashboards or managing inventory of course.
    - *(Optional)* **Receptionist:** If introduced, this role would handle coworking space bookings and check-ins at the front desk. In our system, an admin or a barista could fulfill this function. The codebase already hints at a “Receptionist” group[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/cafe/management/commands/setup_groups.py#L12-L16), which could be used to allow front-desk staff to manage bookings and checkout (final billing).
- **Security Considerations:** Using phone and national ID for auth means we should enforce strong security elsewhere (since national IDs are somewhat guessable). We will use Django’s authentication framework which stores passwords (national IDs) as salted hashes. Additionally, implement **account lockout** or throttling on login attempts to prevent brute-force guessing of IDs. All sensitive pages will require login (using Django’s `LoginRequired` mixin or decorators). We’ll also use HTTPS in production to protect credentials in transit. Session management will follow Django defaults (secure cookies, etc.).
- **Registration Flow:** A new customer can sign up by providing their phone (username) and national ID (which we validate and use as password). We may provide a custom registration form to capture these along with name/email. Optionally, require them to upload their ID card image during registration or later, for verification. Admin should get a notification or view of new registrations to approve if manual verification is desired.
- **Password Management:** Since the password is the national ID by default, we might enforce a password change on first login or provide an interface for users to change their password (in case they want something more private). However, if the business logic is to always use national ID as password (for simplicity), we can keep that rule and instruct users accordingly. (Allowing password change would decouple login from national ID after initial use.)

## Menu & Inventory Management (Cafe Module)

The **café module** will handle menu items, inventory availability, and pricing. This forms the basis for the ordering system. We will design models for **Menu Categories**, **Menu Items**, and possibly basic inventory tracking:

- **Menu Categories:** Each menu item belongs to a category (e.g., Coffee, Tea, Snacks, etc.) for easier browsing. The system will have a `MenuCategory` model with fields like `name` and a sort `order`[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/cafe/models.py#L5-L13). This helps organize the menu in the UI (e.g., list all Coffee items together). Categories can be managed by Admin (add/edit/remove).
- **Menu Items:** A `MenuItem` model will represent each food/drink item the café offers. Fields include:
    - `name` (item name),
    - `description` (optional, e.g., ingredients or size details),
    - `category` (foreign key to MenuCategory)[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/cafe/models.py#L16-L24),
    - `price` (we’ll use a DecimalField for price in Iranian Toman or Rial; decimals=0 since currency is handled in whole Tomans in Iran)[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/cafe/models.py#L18-L21),
    - `image` (optional image of the item for the menu display)[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/cafe/models.py#L18-L21),
    - `is_available` (boolean to quickly mark an item as unavailable/out-of-stock)[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/cafe/models.py#L18-L22).
    - Optionally, `stock_quantity` if we want to track inventory counts (e.g., how many of this item remain). If the café has items that can run out daily (like a limited number of sandwiches), tracking quantity could be useful. We might keep it simple initially (just mark available/unavailable manually) and add quantity tracking if needed.
    
    Admin (or a manager role) can add new menu items or categories through an admin interface or a custom dashboard screen. The **initial menu** from the provided `36 menu.ods` file can be imported or manually entered at project start, ensuring the system starts with all current offerings.
    
- **Inventory Management:** In a simple form, this is handled by toggling `is_available` or adjusting stock counts for menu items. We’ll provide a UI for staff to update an item’s availability (for example, if a certain drink is sold out for the day, the barista can mark it unavailable so customers can’t order it). If more detailed inventory tracking is desired, we could maintain an **InventoryTransaction** log for stock added/removed, but given the timeline, a straightforward approach is likely sufficient:
    - After each order is completed, the system can decrement the stock of each item ordered (if we track quantities).
    - Trigger low-stock warnings for admin if an item’s count falls below a threshold.
    - Provide an inventory dashboard listing all items with current availability and stock count, so the admin or barista can quickly see what’s running low or out.
- **Pricing & Promotions:** The menu item price covers base pricing. If needed, we can incorporate special pricing rules (happy hours, member discounts, etc.) later. Initially, price is fixed per item. All prices and currency will be handled consistently (likely in Tomans as an integer amount for ease, since Decimal 0 places is effectively integer Tomans in the code)[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/cafe/models.py#L18-L21).
- **Data Seeding:** We will likely seed the database with initial categories and items (possibly by reading the ODS or a converted CSV). This ensures the menu is populated early for testing. The codebase can include a Django data migration or management command to load the menu.

## Order Management System (Cafe Orders)

With the menu in place, customers and barista staff will be able to create and manage orders. The order management covers how orders are placed, paid, and tracked:

- **Order Model:** We define a `CafeOrder` model to represent each order/ticket. It will include:
    - Link to a **User** (if a logged-in member is ordering) or a **Guest session** (for walk-in customers who are not logged in)[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/cafe/models.py#L42-L50).
    - Optionally, link to a **Booking/Seat** if the order is to be delivered to someone’s reserved desk or room (room service scenario)[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/cafe/models.py#L42-L50). For instance, if a coworking customer at desk D-3-2 orders coffee, the order can note the booking so staff know where to deliver.
    - A field for **table number or guest name** for walk-in orders (if not attached to a booking)[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/cafe/models.py#L52-L60). E.g., a walk-in customer at café counter could be asked for a name or table location so the barista can call them when ready.
    - **Status** of the order with choices: Pending, Preparing, Delivered, Cancelled[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/cafe/models.py#L35-L43). By default, a new order is “Pending” or “Received”. Barista can update it to “Preparing” when they start making it, “Delivered” when handed off to the customer (or picked up), or “Cancelled” if needed.
    - Timestamps: `created_at` (order time)[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/cafe/models.py#L48-L55), maybe `completed_at` if needed (or we infer from status changes).
    - `is_paid` boolean[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/cafe/models.py#L48-L55) – since payment might be handled in cash or elsewhere, we track if this order has been paid. For members, if we allow accumulating charges (like paying at end of month or upon checkout), `is_paid` could be false until settlement. But likely, each order is paid immediately at the cafe (cash/card), so barista would mark it paid. For now, orders from customers directly might just be assumed paid or require them to pay on pickup (in which case, staff toggles this).
- **Order Items:** Each order has one or more items. We create an `OrderItem` model:
    - Fields: `order` (FK to CafeOrder)[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/cafe/models.py#L62-L65), `menu_item` (FK to MenuItem)[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/cafe/models.py#L62-L65), `quantity`, and `price_at_time`[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/cafe/models.py#L62-L70).
    - We store `price_at_time` to record the item’s price at the moment of order[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/cafe/models.py#L62-L70). This way if prices change later, past orders still reflect what the customer was charged. We can set this automatically in `OrderItem.save()` (if not already set) by copying from the current MenuItem price[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/cafe/models.py#L68-L75).
    - A convenience `subtotal` property (quantity * price_at_time) helps calculate order totals[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/cafe/models.py#L58-L61)[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/cafe/models.py#L68-L75).
    
    Orders and items are linked such that deleting an order will cascade delete its items[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/cafe/models.py#L62-L65).
    
- **Placing Orders (Customer Side):** Logged-in customers (especially those using the coworking space) should be able to place orders from their interface. The app can provide a “Cafe Menu” page where a user can select items (perhaps add to a cart or quickly pick an item and quantity) and then submit an order. Since the frontend is Django templates, a simple approach is:
    - Display the menu grouped by category (each MenuItem with an “Add to Order” button and quantity selector).
    - The user’s current order (cart) could be stored in session or created as a pending CafeOrder (with status Pending, not yet marked paid).
    - When the user finalizes the order, it’s saved and visible to the barista.
    - If the user has an active booking (they are currently sitting in a reserved seat), the UI can ask if they want the order **delivered to their desk**. If yes, we attach their current Booking to the CafeOrder (so barista sees e.g. "Deliver to D-3-2")[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/cafe/models.py#L42-L50). If not (or they’re not a coworking member at the moment), the order could default to pickup at the counter.
    - If the user is not logged in or doesn’t have an account, we might still allow ordering (like a quick order for a café visitor) – in such case, we could generate a temporary `GuestSession` record and attach it to the order to track that session’s orders[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/cafe/models.py#L42-L50). This is advanced and might not be needed if we assume only members order via the app. For now, likely only logged-in customers (members) use the app; walk-ins will order directly with barista.
- **Order Processing (Barista Side):** Baristas will have a dashboard or page to manage orders. Features:
    - **Order Queue:** a live list of new orders (Pending status) with details (items and quantities, who/where to deliver). The barista can click an order to mark it as “Preparing” when they start it, and “Delivered” when done. This updates status so the customer can see the progress (if logged in, they might see “Your order is being prepared/delivered”).
    - Possibly use visual cues (like different color for each status) and maybe sound notifications for new orders (though that could be a future enhancement).
    - The barista should be able to create an order manually as well (for customers who walk up and pay cash). This is the **manual order entry** case. We’ll provide a form where the barista selects items and quantities, and optionally a customer name or table number. They can attach it to a logged-in user if the person is a member, or just treat as guest by filling table/guest name. The form can use a dropdown of users (or search by phone) for members[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/cafe/forms.py#L5-L13), but this might be slow if many users – an alternative is just entering phone to link an account.
    - After preparation, if payment wasn’t collected yet, the barista or cashier ensures payment and marks the order paid (checkbox `is_paid`). In some cases (members with accounts), the system could allow accumulating charges to be paid periodically, but implementing that is optional.
- **Real-Time Updates:** While not strictly real-time, we can implement periodic refresh or use WebSocket for the order queue and customer order status. Given the scope, a simple approach is to use AJAX polling: e.g., the barista page can refresh the orders list every few seconds, or implement a small script to poll for new orders. Similarly, customer’s page could poll for status changes on their order. If we have time, integrating **Django Channels** (WebSockets) could provide true real-time push updates, but this adds complexity. We can decide based on time – initial version can use refresh buttons or polling. (Mark this as an enhancement if needed.)
- **Payment Handling:** Initially, we assume all orders are paid offline (cash/card in person). We track payment status in the database but we are not integrating an online payment gateway in this phase. In the future, if online payments are needed (for example, letting a user pay for their order or their reservation online), we could integrate with an Iranian payment gateway or use a service like Zarinpal/etc. For now, marking orders as paid suffices.

## Analytics & Dashboard

To help the business, we will include an **Analytics Dashboard** for admins (and possibly summary info for baristas). This dashboard will present key metrics and allow data-driven decisions. Features to implement:

- **Top Selling Items:** Calculate which cafe menu items are the most popular. We can query the database for total quantity sold per MenuItem (summing OrderItems over a time period, e.g., last month or all-time). The dashboard can display the top 5 or 10 items, with their names and quantities sold (or total revenue from each). This could be in a simple table or a bar chart (if we integrate a chart library or use a JS chart). For instance, “Espresso – 120 sold this month” etc.
- **Top Buyers / Loyal Customers:** Identify customers who have made the most purchases or spent the most money. We can aggregate CafeOrders by user, sum the total price, and list the top customers. This helps identify loyal members or heavy users. (This requires that orders link to user accounts; guest orders won’t be counted unless later associated with a user.) The dashboard might show, for example, “Customer Alice (Phone 0912xxxx) – 5 orders, 1,200,000 Toman spent in last month”. This info is useful for loyalty rewards or just understanding usage.
- **Sales Over Time:** We could show daily/weekly sales totals or order counts, maybe in a simple chart or table. For instance, how many orders per day, or total revenue per day. Since timeline is short, a simple textual summary (e.g., “Orders today: 10, Total sales: 500,000 T”) might suffice, but we will structure the data to allow adding charts later.
- **Inventory Alerts:** If we track stock, the dashboard can list items low in stock or frequently sold out. E.g., “Croissants – only 5 left in stock” or “Latte – sold out 3 times this week”. This helps admin know what to restock or which items are in high demand.
- **Reservation Utilization:** Although primarily for cafe analytics, the admin dashboard can also show coworking space stats – e.g., occupancy rates (# of seats occupied today vs available), monthly memberships count, etc. For example, “10/15 daily seats occupied now, 8/10 monthly seats rented” can give a quick overview of space utilization.
- **Manual Data Entry & Export:** Allow admin to filter and view all orders and reservations, possibly export data (CSV reports) for accounting. Not absolutely required in initial version, but useful for auditing. We can leverage Django admin for raw data export, or build a custom export in the dashboard.

The analytics will involve writing efficient queries or utilizing Django’s aggregation. We’ll use the Django ORM (annotate, aggregate) to compute the sums and counts needed for the above. These computations should be done on the server (views querying the database) and then passed to templates for display. If performance becomes an issue (large data), we might consider caching some results or building summary tables, but that’s likely not needed initially.

## Seat Management & Floor Plan (Coworking Space)

Now focusing on the coworking reservation side: we need to define the **seating layout** and rules for which seats can be reserved on what basis. The provided floor plan (SVG/JPG image of the space) will be used to create an interactive map of the workspace.

**Seat (Space) Model:** We will create a `Space` (or `Seat`) model to represent each reservable unit – whether it's a single desk, a spot at a communal table, a meeting room, or a private office. Each Space will have attributes:

- `name`: Identifier for the space (e.g., "Desk D-3-2" or "Meeting Room B"). We can devise a naming scheme. The code suggests names like *T-Left-1*, *D-1-1*, *Office 201*, etc., which correlate to location[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/management/management/commands/seed_spaces.py#L26-L35)[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/management/management/commands/seed_spaces.py#L86-L95).
- `zone` or `type`: A classification of the space, which determines its usage rules. For example, zones might include **LONG_TABLE** (communal long tables), **PRIVATE_ROOM** (offices or meeting rooms), **CLASSROOM** (individual desks in rows) as seen in code[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/management/management/commands/seed_spaces.py#L26-L35)[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/management/management/commands/seed_spaces.py#L86-L95). We will define choices for these. The zone will help enforce rules (e.g., a zone “LONG_TABLE” might mean daily-only booking)[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/GEMINI.md#L30-L34). Specifically:
    - *Middle long table:* daily only (no monthly).
    - *Side 4-person tables (6 tables x 4 seats):* monthly only, possibly meaning these seats are allocated to monthly members and not available for day booking.
    - *Single desks (one-seaters):* available for both daily drop-in or monthly membership.
    - *Meeting room:* only bookable hourly or daily (no monthly).
    - *VIP private office:* bookable hourly, daily, or monthly (flexible).
        
        We can either incorporate these rules via the `zone` or have explicit boolean fields like `allow_daily`, `allow_monthly`, `allow_hourly` for each space. Using zone with a lookup table of what’s allowed is a clean way. For example, in code: *Booking model will validate that if a space’s zone is LONG_TABLE, you can’t create a monthly booking on it*[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/GEMINI.md#L30-L34).
        
- **Capacity**: how many people the space can accommodate. A single desk = 1, a meeting room might be 6 or 8, a 4-seat table could be capacity 4 (though we might treat each seat at a table as a separate “Space” in the system if they can be booked individually). Here we must decide: do we model each individual seat at the 4-person tables as separate Spaces (so 24 individual seats that are grouped by table), or one Space per table? For monthly reservations, they might rent the whole table to a team (in which case one Space = one table with capacity 4). But the user’s description “6x4 tables for monthly” suggests perhaps treating each table as a single rentable unit for a team (since they didn’t say 24 separate seats for monthly). However, in coworking it's more common each seat is individual. We need clarity:
    - If the intention is to rent out each seat, then we should represent each seat at those tables as separate Space entries (and possibly mark them grouped). But then a team could rent multiple seats anyway.
    - If the intention is to rent the entire 4-seat table to one customer (like a private cluster for a team), then model it as one Space with capacity 4 (and maybe note it's a "team table").
    
    Given the phrasing, it might mean *six tables* reserved for monthly users, but possibly different individuals can take different seats at those tables (like a fixed desk). To keep it straightforward, we will treat each seat as a Space. If they want to book a whole table, they would just book all 4 seats. (Admin can facilitate that by grouping seats, but that can be manual).
    
- **Coordinates for Floor Plan:** To display on the floor map, each Space will have coordinates corresponding to the SVG/image layout. We can overlay a CSS Grid or absolute positioning on the floorplan image. The repository plan suggests using a **CSS Grid** approach where each Space has `grid_row`, `grid_col`, and span values to position it on a grid that matches the floor dimensions[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/GEMINI.md#L34-L40)[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/management/management/commands/seed_spaces.py#L28-L36). For example, the Space "Meeting Room A" might occupy a 6x4 grid area at the top-left[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/management/management/commands/seed_spaces.py#L26-L35). We have an image `final-floor-plan.jpg` as background[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/static/css/style.css#L200-L208) and we will overlay divs for each Space on it. Each Space div can be color-coded or annotated (e.g., green if available, red if occupied). We’ll use the coordinates from the model to place them via CSS Grid or absolutely positioned elements. This approach makes the map dynamic (no need to edit the image for availability) and responsive[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/GEMINI.md#L34-L40).
- **Pricing Plans:** To handle different pricing for daily/hourly/monthly for each type of space, we will introduce a `PricingPlan` model (as the repository suggests)[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/GEMINI.md#L28-L34). This decouples pricing from the space itself. For example, we might have a PricingPlan for “Standard Desk” with fields for daily_rate, hourly_rate, monthly_rate; another for “Private Office” with its rates, and “Meeting Room” with perhaps only hourly and daily rates defined. Each Space is associated with a PricingPlan that reflects its type[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/management/management/commands/seed_spaces.py#L10-L19). This way, if we need to update prices (say increase the monthly fee for VIP room), we change the plan rather than every space. It also allows showing the cost to the user when booking (e.g., “This desk costs 150,000 Toman per day or 3,000,000 per month” if we have that data).
    
    PricingPlan can have fields: name, daily_rate, hourly_rate, monthly_rate (some might be null or 0 if not applicable, e.g., meeting room might not have monthly_rate). The seed data in the repo, for example, created a standard plan (daily 150k, hourly 30k) and a meeting plan (daily 1,000k, hourly 200k)[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/management/management/commands/seed_spaces.py#L10-L19).
    
- **Seating Data Initialization:** Using the floor plan image and description:
    - The **middle long table** (the big communal table) will be one or multiple spaces? Likely it’s a long table with multiple chairs, but since they said it’s for daily customers, we might treat each seat at it as a daily space. If the table seats, say, 6 people, we could have 6 spaces for it. However, since it’s communal and only daily, an alternative is to treat the entire table as a single daily “coworking area” that can host multiple people without reservation (like a hotdesk area). But to keep consistency (and track occupancy count), it’s better to represent individual spots.
    - The **6x4 monthly tables**: If we treat each seat as Space, that’s 24 spaces designated monthly-only (so allow_monthly=True, allow_daily=False). If we treat table as a unit, 6 spaces with capacity 4 – but Django models would need to handle partial occupancy if so. Simpler: treat each seat as a unit.
    - **Single person desks (12 one-seaters)**: These will be 12 Space entries, which allow both daily and monthly.
    - **Meeting room**: 1 or 2 spaces (maybe they have one meeting room?). The user said "the meeting room" (singular) – maybe one. It’s hourly/daily only.
    - **VIP rooms**: Possibly the private offices (like Office 201, 202 in code) are considered VIP rooms. Those allow all booking types. We have at least 2 from seed code, maybe more in actual plan.
    
    We will encode all these into the Space table at project setup (via migration or seed script). The provided floor plan image can guide the exact coordinate placement.
    
- **Real-Time Availability Status:** Each Space will have a status at any given time: available, reserved, or maybe maintenance (if temporarily out of service). We don’t store status directly on the Space model (since it’s derived from bookings), but we can compute it or cache it:
    - If there is an active booking covering today (for daily/monthly) or the current hour (for hourly) for that space, then it’s **occupied/reserved**.
    - If not, it’s **available**.
    - We might also allow marking a space as under maintenance or unavailable manually (e.g., a chair broken). In that case, an admin toggle could set an override flag (Space.is_active = False or similar), which would make it unavailable regardless of bookings.
    
    The front-end will show a color indicator on each seat: e.g., green dot for available, red for reserved, blue for maintenance[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/static/css/style.css#L176-L184). We see CSS classes defined for `.dot.available`, `.dot.reserved`, etc., likely for this purpose[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/static/css/style.css#L176-L184). We will generate the HTML for the floor grid by looping through Space objects and assigning a class based on availability[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/GEMINI.md#L34-L40).
    
- **Floor Plan UI Implementation:** The interface to display and interact with the seating will be a key part of the project:
    - We will create a page (say “Reservations” or the homepage after login for members) that shows a **map of the coworking space**. Using the CSS Grid overlay approach[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/GEMINI.md#L34-L40), the page will contain a container div with the background image of the floor plan (for visual context) and absolutely or grid-positioned child elements for each Space. Each Space could be a small clickable element (like a chair icon or a colored square) positioned at its location.
    - The elements will be color-coded (or use colored dots) to show availability. Perhaps green for free, red for taken[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/static/css/style.css#L176-L184). If maintenance or closed, a different color (blue)[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/static/css/style.css#L177-L184).
    - When a user clicks an available space, we can open a dialog or navigate to a booking form for that space (pre-selecting the space in a booking form). If they click a reserved space, we might show “Occupied by [member] until [date/time]” (though for privacy maybe just “Occupied”).
    - For performance, we should fetch all spaces and their status in one go (using select_related/prefetch to avoid N+1 queries)[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/GEMINI.md#L36-L40). Possibly, we’ll annotate each space queryset with a boolean or status via a subquery checking bookings. Alternatively, we compute availability on the fly in Python by checking against a cached set of currently booked space IDs.
    - The layout should be responsive: On mobile, the grid might scroll or scale. We have CSS making the `.floor-grid` scrollable horizontally on small screens[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/static/css/style.css#L40-L48) and maintaining aspect ratio[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/static/css/style.css#L196-L204). We will test the UI on different screen sizes.
    - **Note:** The design decision in the repo is to avoid using a <canvas> or <img> map with clickable regions, and instead use pure CSS/HTML for responsiveness[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/GEMINI.md#L34-L40)[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/GEMINI.md#L64-L70). We'll follow this approach.

## Reservation Booking System & Logic

Building on the seat management, the reservation system allows customers to reserve a seat or room either for a day, hour, or month, depending on the space type. Key components:

- **Booking Model:** We will create a `Booking` (or Reservation) model to record each reservation. Fields likely include:
    - `user` (the customer who made the reservation, ForeignKey to User).
    - `space` (the Space being reserved, ForeignKey to Space).
    - `start_time` and `end_time` (for hourly bookings, or date range for daily/monthly). For daily bookings, we could use a date field (or treat it as start_date with implicit 1-day duration). For monthly, perhaps store start_date and end_date as one month apart, or a month indicator.
        - Alternatively, we can have a field `booking_type` (choices: hourly, daily, monthly) and interpret the dates accordingly (e.g., for daily maybe just start_date and assume one day, for monthly maybe store the month’s start date and calculate end date after 30 days).
    - `status` (active, completed, cancelled, no-show, etc. Initially “active/confirmed” when booked).
    - We might also record `created_at` (booking time) and `price_charged` for the reservation (like how much the reservation costs, based on PricingPlan and duration). This can be useful for billing or checkout.
    - If needed, `payment_status` if they pay for reservations (perhaps members pay upfront for monthly, or pay on check-in for daily).
    
    We’ll ensure the Booking model and logic enforce the **business rules**:
    
    - A given Space cannot have overlapping bookings in a way that violates its allowed usage. For example, if a space is booked for a certain day, no other booking should overlap that period. We will implement a utility function like `check_availability(space, start, end)` to verify no conflicting booking exists[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/GEMINI.md#L42-L45). This will be used when creating a new booking.
    - For monthly bookings: if someone books a space for a month (or has a membership for that desk), that space should be marked unavailable for the entire duration (likely a month starting from a given date). The system should prevent any daily or hourly bookings within that range. Possibly, we might block overlapping monthly bookings entirely (one seat can’t have two monthly subscribers at the same time).
    - For daily bookings: if a space is booked for a particular day (or date range), it’s not available to others on that day. We define whether daily means just 9am-6pm that day (if business hours) or 24 hours from start – depends on how the space is offered. Likely, daily means that working day until closing.
    - For hourly bookings: only applicable to meeting rooms or VIP maybe. We need to ensure we store start and end times with time-of-day precision for those. The availability check should ensure no overlapping hours. Possibly implement bookings in hour blocks (e.g., 9:00–10:00).
    - Enforce zone rules: e.g., if someone tries to create a monthly booking on a space that is daily-only, we reject it. Or if hourly booking on a space not allowed hourly, reject. This can be done either in the view or as a model clean() method or signal. According to the plan, *“Booking: central ledger. Validates zone logic (e.g., Long Table = Daily only”)[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/GEMINI.md#L30-L34)* – we’ll implement such validation.
- **Booking Workflow (Customer):**
    1. The customer (logged in) navigates to the floor plan and selects an available seat or room.
    2. A booking form is presented. They choose the type of reservation:
        - If the space allows hourly: let them pick date and start/end times (perhaps with a time picker).
        - If daily: pick a date (or multiple days? but likely one day at a time for simplicity).
        - If monthly: likely choose the start date of the month (or just choose “this month” vs “next month”), or perhaps just an option for “start immediately for one month”. In MVP, we can assume monthly starts on the day of booking and lasts 30 days, or starts at beginning of the next month. The exact policy can be defined with the business (e.g., pro-rate if starting mid-month or always full month cost).
    3. The system calculates the price (e.g., using PricingPlan: if daily, use daily_rate; if hourly, hourly_rate * hours; if monthly, monthly_rate). Display this to the user for confirmation.
    4. When the user confirms, we create the Booking record as pending or confirmed (depending if payment is required).
    5. **Payment for booking:** If these reservations are paid (very likely, especially for daily/hourly), we need to decide how to collect payment. Possibly, customers pay in person at the reception or via an online link. In our scope, we might assume they will pay at the venue (or that monthly members pay upfront offline). So we can record the booking and mark payment status accordingly. If needed, integration with a payment gateway could be a future enhancement (so the user can pay online to secure the booking).
    6. After booking, the seat becomes unavailable to others for that period. The user can view their upcoming bookings in an account page.
    7. On the day of a booking, perhaps the receptionist or admin would check the user in. But if it’s mostly self-serve, we might not need a check-in step in software, unless to mark a no-show or release seat if they don’t come.
- **Administrative Booking Management:** Admins or receptionists should be able to create, view, and cancel bookings as well:
    - A calendar or list view of all bookings can be provided (maybe not full calendar in MVP, but at least a list sorted by date or a per-space listing).
    - Admin can book a seat for a customer (e.g., if someone calls or walks in).
    - They can cancel or modify bookings. Cancellation rules (refunds etc.) are business decisions; at least allow cancellation.
    - Possibly, at the end of each day or month, an admin might want to “check out” all daily visitors and produce a summary bill (if they consumed cafe items, etc.). This ties into a potential **checkout process**: for example, a member reserved a seat for a day and also ordered coffee, so at checkout the receptionist combines their seat fee + orders to one bill[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/GEMINI.md#L54-L58). The plan mentions *“Reception: Atomic checkout (Sum Booking + Sum Cafe Orders)”*[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/GEMINI.md#L54-L58), meaning the receptionist can see all charges for a user and settle them in one transaction. Implementing this would involve linking orders with bookings or users and generating an invoice. Given time constraints, we might not fully implement a payment checkout system, but we keep the data such that it’s possible (e.g., know which orders belong to which user and day).
- **Real-Time Updates for Availability:** When a booking is made or canceled, the availability status on the floor plan should update for all users viewing it. Initially, we can require a page refresh to see updates. If we want true real-time, we could use WebSocket broadcasts to update the status of that one seat (change its color to red, etc.). This again could be done with Django Channels or a simpler approach where the client polls periodically for changes. Depending on timeline, we might implement a lightweight polling (e.g., every 30 seconds reload availability status via AJAX). Real-time is a nice-to-have; the essential is that if a user tries to book a seat that just got taken, the system will prevent it (by check on submit).
- **Concurrent Booking Handling:** We must handle the case of two users trying to book the same seat at roughly the same time. Even with a real-time display, race conditions can occur. Our `check_availability` function will be the gatekeeper – when a user submits a booking request, the server double-checks no conflicting booking exists *at that moment*. We will likely wrap booking creation in a transaction and use a **unique constraint** on (space, timeslot) or a SELECT FOR UPDATE on the space’s bookings to avoid race conditions. If a conflict is detected, we’ll return an error to the user (“Sorry, that seat was just taken”). This is a backend safeguard.
- **Monthly Membership Management:** For monthly reservations, additional logic:
    - If a user has a current monthly booking for a seat, perhaps we show that on their profile and maybe block them from booking another monthly seat (unless they cancel the first – typically one person would only need one monthly desk).
    - We should also ensure monthly bookings align to calendar or at least clearly define duration. Possibly, we can simplify: a monthly booking always lasts 30 days from start.
    - There should be an easy way for admin to extend a monthly booking (renew for another month) or for the system to allow the user to renew.
    - After a monthly period ends, the seat becomes available again (we may have a cron or script to expire bookings, but since we store end_date, we can just filter out expired ones in availability checks).

In summary, the reservation system is essentially an **appointment/booking scheduler** for physical spaces, with some specific rules. We will thoroughly test the booking logic to ensure no double-booking and that the rules (daily vs monthly, etc.) are respected.

## User Roles & Interfaces

Bringing it together, different roles will interact with different parts of the system:

- **Admin Interface:** Admin will likely use a custom dashboard that we build, or the Django admin site for some backend management. The admin’s responsibilities and interface include:
    - Managing users (viewing member list, perhaps creating accounts, or resetting passwords).
    - Viewing and editing the menu and inventory (add/edit items, mark availability).
    - Viewing all orders and reservations (the analytics dashboard as described, plus detailed lists).
    - Managing spaces (maybe a CRUD interface for Space and PricingPlan in case layout or prices change).
    - Overriding/cancelling bookings if needed.
    - Admin could use the Django admin site for many of these tasks initially to speed up development (Django admin is a quick way to manage models without coding a UI). We can enable admin site for MenuItem, CafeOrder, Space, Booking, etc., as a backup while we build nicer UIs.
    - The admin dashboard page (if we make one) will summarize key info (orders today, upcoming reservations, etc., as discussed in Analytics).
- **Barista Interface:** The barista will primarily use the **Cafe Order Management** pages:
    - A page to see incoming orders (with sound or visual alert for new ones).
    - Ability to update order status easily (e.g., a button or drag-drop).
    - A form to create new orders for walk-ins.
    - Possibly a quick toggle for marking menu items unavailable if something runs out (so they don’t have to call an admin to do it).
    - The barista might not need to interact with the seat reservation system much, except perhaps to know if a person sitting in the space ordered something (but our system linking booking to order already gives that info to the barista per order).
    - They likely won’t use the floor plan interface, except maybe to see which desk corresponds to an order (the order might show “deliver to Desk D-1-3”).
    - We will ensure the barista group has access only to the needed views. We can create separate URL patterns for barista dashboard vs admin.
- **Customer Interface:** For customers (members or new users), the experience will include:
    - **Browsing the Menu:** See the café menu (with categories, item images, prices) – even without logging in this could be public.
    - **Placing Orders:** If logged in, add items to a cart or order and submit. If not logged in, maybe they can’t order (or we allow guest checkout via phone number? But that complicates – likely require login to use the app ordering).
    - **Viewing Order Status:** After placing an order, the customer can see its status (Pending/Preparing/Ready) in real-time or via refresh.
    - **Booking a Space:** Viewing the coworking space availability map (this might require login, especially if booking is only for registered users). They can see which seats are free and select one to reserve.
    - **Managing Reservations:** A page listing their current and upcoming reservations. Possibly allow them to cancel a reservation (with some advance notice policy).
    - **Profile/Account:** They might have a profile page showing their details (phone, ID, maybe they can update some info except phone/ID which are fixed). They might also see their order history and maybe receipts.
    
    The front-end for customers should be user-friendly and mobile-first (since many will use their phone). We saw in the design notes the plan for a **mobile-first, RTL interface for the cafe**[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/GEMINI.md#L50-L53), meaning the UI will support Persian language and right-to-left layout (as seen in CSS `direction: rtl` in the body)[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/static/css/style.css#L14-L22). We should indeed ensure the Persian localization: use Persian labels for the cafe form (as already in code)[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/cafe/forms.py#L5-L13), and possibly support Farsi translations of the UI text via `gettext`. This will make the system usable for local staff and customers (who likely prefer Persian). The admin might use English or Persian depending on preference – we can make the UI bilingual if needed.
    

## Development Phases & Timeline

Given an estimated timeline of **1-2 months**, we will break the project into phases with specific deliverables. This ensures we have a working core early and can progressively add features:

**Phase 1: Core Setup (Week 1)** – *Goal: project foundation and auth*

- Initialize the Django project (if not already done). Configure settings for SQLite (dev) and set up switching to PostgreSQL for production via environment variables[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/GEMINI.md#L10-L15). Install necessary packages (ensure we have pillow for images, etc.).
- Set up the **User model** modifications: either use a custom user model with phone, or create a `UserProfile` extending `auth.User`. Given simplicity, a `UserProfile` model might be fine to add phone and national_id fields[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/GEMINI.md#L30-L34). Alternatively, since using phone as username is critical, it might be cleaner to implement a custom user model now (since changing later is hard). We’ll decide early and implement it.
- Implement **registration and login** views/forms that use phone & national ID. Include the national ID validation function here. Test that a user can create an account and log in.
- Implement group creation for **Admin** and **Barista** (possibly via a script or in code)[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/cafe/management/commands/setup_groups.py#L10-L17). Assign any initial test users to these groups.
- Basic templates for login/register, and maybe a base layout with navbar or sidebar to use later. No heavy front-end yet, just ensure we can navigate after login.

*Deliverable:* Working auth system where a user can sign up and log in with phone/ID. Admin user can log into Django admin.

**Phase 2: Menu & Inventory Module (Week 2)** – *Goal: manage cafe menu*

- Create models for **MenuCategory** and **MenuItem** as described[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/cafe/models.py#L5-L13)[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/cafe/models.py#L16-L24). Apply migrations.
- Set up Django admin for these models so items can be added easily for now. Load initial menu data (either via admin or a script from the ODS file if possible).
- Create views/templates for customers to **view the menu** (public or after login). This could simply list categories and items, showing name, price, description, and whether available. This page helps customers know what’s offered and maybe plan orders.
- (Optional late Phase2 or Phase3) Provide admin/barista interface to add/edit menu items outside of Django admin – not critical if admin is acceptable, so this can be postponed. A quick use of Django admin might suffice for the short term.

*Deliverable:* Menu items can be managed (at least via admin) and displayed on the site. Inventory availability toggle works.

**Phase 3: Order Management Module (Weeks 3-4)** – *Goal: ordering system functional*

- Create models for **CafeOrder** and **OrderItem** with relations to User, MenuItem, etc[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/cafe/models.py#L42-L50)[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/cafe/models.py#L62-L70). Include fields and choices for status. Migrate and test creating orders.
- Implement the **customer ordering workflow**: menu page with an “Add to order” or direct “Order” functionality. This likely involves creating a cart session or immediate order creation. For simplicity, we might implement a quick order form: the user selects a quantity and item, submits, and we create an order with that single item (for multiple items, user repeats or we make a small cart). However, better is a cart: allow adding multiple items then finalizing one order. We can do this with session storage or a temporary Order record.
- Create the **Barista order queue page**: use Django views to query all pending orders and display them. Use some AJAX or auto-refresh to update it frequently. Include buttons or links to update status (which trigger a small view or use Django admin actions). We can make each order row clickable to see details and change status. Ensure that when status changes, both barista view and user view reflect it (maybe via page refresh or AJAX).
- Implement the **manual order form** for barista: a page where barista can create an order. Use a ModelForm for CafeOrder (with optional user field as in code) and inline formset or a custom UI for adding items (could also just provide a multi-select or repeated item add). Since this can be complex, an easier approach: barista selects an item and quantity and clicks “Add” repeatedly, which behind the scenes creates OrderItems attached to a new CafeOrder (like building the order). Or use a small JavaScript to allow adding item rows before submitting. We’ll try to make it user-friendly but keep it within our time (could also leverage Django admin’s inlines as a quick solution for barista, but admin UI might be too technical for daily use).
- Testing: simulate an order by a customer, ensure barista sees it and can mark it delivered. Simulate a barista creating an order for a guest.
- Internationalization: ensure the barista interface is in Persian (labels, directions RTL) for ease of use (the code already shows Persian labels on forms, we will use that)[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/cafe/forms.py#L5-L13).

*Deliverable:* Customers can place orders from the menu, and baristas can view and fulfill those orders. Orders update status and are stored with correct relations. Basic payment status toggling in place.

**Phase 4: Analytics Dashboard (Week 4)** – *Goal: admin insights*

- Create a view for admin dashboard that aggregates data from orders (and later bookings). Focus on implementing queries for **top sellers** and **top buyers** as specified. Use Django’s ORM annotate/Count to get top 5 items sold and top 5 users by total spent. Render these in a template (initially as lists or tables).
- Add summary stats like total orders today, total revenue today, etc. and maybe a list of today’s orders or recent orders.
- If time permits, integrate a chart library (or use a simple Google Charts or Chart.js via CDN) to plot something like sales over the last week.
- Also include some reservation stats if Phase 5 is done (if not, we’ll integrate later).
- Ensure this page is only accessible to admin (use @login_required and check group or staff status).
- Test with some dummy data (create orders manually or via script to see that counts work).

*Deliverable:* Admin can view a dashboard page with key metrics (top items, top customers, sales stats). This helps track performance.

**Phase 5: Space & Reservation Backend (Week 5)** – *Goal: coworking space data model ready*

- Define models for **PricingPlan**, **Space**, and **Booking** as discussed[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/GEMINI.md#L28-L34). Add choices for space zone (e.g., an enum in Django model for zone types). Fields for coordinates and allowed booking types. Migrate the models.
- Create initial entries for PricingPlan (for example Standard Desk, Private Office, Meeting Room with appropriate rates)[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/management/management/commands/seed_spaces.py#L10-L19).
- Create entries for Space for each seat/room according to the floor plan. We can write a **management command or migration script** to seed the Space table with all the seats using provided layout (the repository already has a `seed_spaces.py` which we can adapt)[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/management/management/commands/seed_spaces.py#L26-L35)[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/management/management/commands/seed_spaces.py#L86-L95). This includes setting the zone and pricing plan for each, and coordinates.
- Implement the Booking model logic:
    - Perhaps override `clean()` or use a custom method to validate no overlapping booking when saving. Or more straightforward, handle it in the view when a booking is made.
    - Write the `check_availability(space, start, end)` helper[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/GEMINI.md#L42-L45). This function queries existing bookings for the space to see if any conflict with the desired time.
    - We will also incorporate zone rules: e.g., if booking_type is monthly but space.zone == LONG_TABLE (daily-only zone), then treat as not available (or not allowed).
- No user interface yet in this phase, just backend. Test by manually creating some Booking objects in the shell or admin to ensure constraints logic works (e.g., try two overlapping bookings, see that our code prevents it).

*Deliverable:* Data structures for reservations are in place and seeded with actual space data. The system “knows” about all seats and rooms and their booking rules.

**Phase 6: Reservation Frontend & Real-Time Map (Week 6)** – *Goal: users can book via interactive floor plan*

- Develop the **Floor Plan page** for customers. This involves:
    - An HTML template that renders the grid of Spaces. We iterate over all Space objects, and for each, output a div or button at the proper grid position (using inline CSS or classes based on `grid_row` etc.)[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/GEMINI.md#L34-L40). Use the background image of the floor in the container for visual reference[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/static/css/style.css#L200-L208).
    - Color-code or indicate availability. We can do this by adding a class like `reserved` or `available` on each element depending on `space.is_available` (which we determine in view context by checking current bookings)[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/static/css/style.css#L176-L184). Maybe also show the name or number of the seat on the element (tiny text or on hover).
    - Make these elements interactive: wrap them in a form or link. For an available space, clicking could direct to a booking form for that specific space. For a reserved space, clicking might do nothing or show info (if admin logged in, maybe show who reserved).
    - Implement the **Booking form** view. When user chooses a space, present a form where they select date/time and booking type. This form needs to enforce allowed type (e.g., if space.allow_monthly is false, hide that option). Use a calendar/date picker for daily or monthly start, and a time picker for hourly if applicable.
    - When form is submitted, in the view: validate again with `check_availability` then save the Booking and redirect to a confirmation or the map with success message. If unavailable (race condition), show an error.
    - If booking requires payment, for now either mark it as unpaid and let them pay on-site, or simply assume they'll pay and mark as paid. We might include a note like "Please see the receptionist to complete payment."
    - Update the floor plan view to reflect the new booking (if we redirect back there, the seat should now show reserved). *Real-time:* we can add a small AJAX that periodically fetches an endpoint giving current reserved spaces (maybe just a JSON of available ids) and updates the classes. This can be done if time permits to give a near-real-time feel.
- **Reservations List:** Create a page for the user to see their bookings. List active (upcoming or ongoing) and maybe past bookings. Allow them to cancel if the booking is for the future (and within cancellation period if any policy). Cancellation would delete the Booking (or mark it cancelled) and free the space.
- **Admin/Staff View of Reservations:** We might add a view for staff to see today's bookings (who is expected today, etc.), and all active monthly members. This could be a simple table: Space – booked by – type – dates. Useful for reception to know who’s sitting where. If receptionist role is used, they would rely on this.
- **Testing:** We must test various scenarios:
    - Book a daily seat, then ensure it’s unavailable for that day.
    - Book an hourly meeting room, ensure overlapping not allowed.
    - Try booking a monthly seat and then a daily on the same seat next day – should conflict if within that month.
    - Cancel a booking and see it frees up.
    - Ensure the pricing logic charges correct amount (if we display price).

*Deliverable:* Customers can view seat availability on a map and create reservations. The system enforces booking rules. Staff can view the reservations.

**Phase 7: Final Touches and Deployment (Week 7-8)** – *Goal: polish and go-live*

- **Integration and UX:** At this point, all major features are in place. We will refine the UI: ensure navigation links are set (e.g., link from dashboard to relevant sections, add menu links for Orders, Reservations, etc.). Add appropriate success/error messages in forms. Ensure forms have Persian labels where needed and validation messages are user-friendly.
- **Access Control:** Double-check that pages are protected by login and by role. For example, barista pages shouldn’t be accessible by customers (we can use @user_passes_test or custom middleware). Admin pages only by admin group.
- **Visual Design:** Apply CSS styling to make the app look clean. The provided CSS (with dark theme, etc.) can be integrated[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/static/css/style.css#L14-L22)[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/static/css/style.css#L146-L155). Ensure responsiveness on mobile (the CSS already has some adjustments for smaller screens[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/static/css/style.css#L24-L32)). If needed, tweak the floor grid on very small screens (maybe show a simplified list view as fallback).
- **Performance Optimizations:** Use `select_related` / `prefetch_related` in querysets for orders and bookings to minimize database hits when listing data[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/GEMINI.md#L36-L40). For example, when rendering the floor plan, prefetch current bookings so that checking availability doesn’t query in a loop. Also, consider adding indexes on fields like space ID in Booking, etc., for fast lookups.
- **Testing & QA:** Do an end-to-end test as if we’re a customer booking a seat and ordering coffee, and as a barista fulfilling orders, as an admin viewing stats. Fix any bugs or logic issues uncovered.
- **Deployment Prep:** Configure the app for production:
    - Adjust settings for ALLOWED_HOSTS, DEBUG False, static files collection, etc.
    - Set up the PostgreSQL database and run migrations on it, test there.
    - If deploying to a server, set up Gunicorn/Uvicorn and Nginx, or if using a PaaS, prepare the config (maybe a Dockerfile or Heroku config).
    - Populate initial data for production (menu, spaces, admin account, etc.). We might use fixtures or the seed scripts.
- **Future Enhancements:** Document any features that are deferred but could be added later, such as:
    - **QR Codes**: Generate a QR for each seat/table that leads to the ordering page for that seat[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/GEMINI.md#L58-L61). This way, a customer could scan a QR at their desk to open the app and order directly tied to that desk.
    - **Online Payment** integration for bookings or orders.
    - **Notifications**: send SMS or email confirmations for bookings, or order-ready notifications.
    - **Enhanced Calendar view** for admin to see all bookings.
    - **Mobile app** or PWA if needed for easier access.
    
    These are beyond the initial 1-2 month scope but are good to keep in mind.
    

*Deliverable:* A polished, deployed web application ready for use in the coworking space, with all major features tested. Admin can manage the space and cafe efficiently, barista can handle orders, and customers can book seats and order from the cafe in real-time.

## Conclusion

By following this detailed plan, we ensure the project is built in a systematic, modular way. We started with the core authentication (using phone and national ID for secure login), then established the cafe’s menu and ordering system, and finally layered on the complex reservation system for coworking seats, all integrated through a unified platform. The use of Django provides a stable framework with built-in admin and auth, speeding up development.

Throughout development, we will maintain clean separation of concerns: user management, cafe operations, and space bookings, while also enabling them to work together (e.g., linking cafe orders to coworking bookings for delivery). The real-time floor plan and order updates will greatly enhance user experience by showing up-to-date information[GitHub](https://github.com/rezashariatmadar/36-cowork-website/blob/4458ace7e395eb33f2657d9706e16daba9a916e6/GEMINI.md#L34-L40). Analytics and role-based dashboards will help the business make informed decisions and streamline operations.

In summary, this plan lays out **what to build, how to build it, and in what sequence**, minimizing complexity by tackling features in logical increments. By the end of the project, the coworking space will have a robust system to manage memberships and reservations alongside café sales, all within one cohesive web application.